<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Replay Trimmer for TETR.IO</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
.note,h1{text-align:center}body{font-family:"JetBrains Mono",monospace;background:#0e0e10;color:#fff;margin:0;padding:1rem}.controls,h1{margin-bottom:.5rem}h1{color:#64ffda;font-size:1.3rem}.controls{display:flex;gap:.5rem;align-items:center;justify-content:center}input[type=file]{color:#ddd;font-size:.9rem}.header{display:flex;justify-content:space-between;padding:0 .5rem;color:#ccc;font-weight:600;font-size:.95rem;margin-bottom:.4rem}#downloadBtn,.player.alive,.player.dead,.round-title{font-weight:700}.center,.stats{font-size:.85rem;display:flex}.round-box{display:flex;align-items:stretch;background:#1a1a1d;border-radius:8px;margin-bottom:.5rem;overflow:hidden;box-shadow:0 0 6px rgba(100,255,218,.06)}.player{flex:1;display:flex;flex-direction:column;align-items:center;justify-content:center;transition:.15s;padding:.6rem .4rem}.player.alive{background:linear-gradient(180deg,rgba(0,191,255,.2),rgba(0,191,255,.06));box-shadow:inset 0 0 10px rgba(0,191,255,.3);color:#00bfff;text-shadow:0 0 4px rgba(0,191,255,.5)}.player.dead{background:linear-gradient(180deg,rgba(255,77,77,.2),rgba(255,77,77,.06));box-shadow:inset 0 0 10px rgba(255,77,77,.3);color:#ff4d4d;text-shadow:0 0 4px rgba(255,77,77,.5)}.player.neutral{background:0 0;color:#ddd;font-weight:600;text-shadow:none}.stats{margin-top:.2rem;gap:.5rem;justify-content:center}.center{width:120px;flex-direction:column;align-items:center;justify-content:center;background:#0f0f10;border-left:1px solid #161616;border-right:1px solid #161616;color:#64ffda;padding:.3rem 0}.center div{margin:.15rem 0}.delete-btn{background:#ff4d4d;border:none;border-radius:5px;color:#fff;padding:.25rem .4rem;cursor:pointer;font-size:.8rem}.delete-btn:hover{background:#ff1a1a}#downloadBtn{background:#64ffda;color:#000;border:none;border-radius:6px;padding:.45rem .9rem;cursor:pointer;display:none;margin-left:.5rem}.footer-controls{display:flex;justify-content:center;gap:.5rem;margin-top:.75rem}.note{color:#aab;font-size:.8rem;margin-top:.3rem} .file-input-wrapper{position:relative;display:inline-block;overflow:hidden;border-radius:8px;background:#111;box-shadow:0 0 8px rgba(100,255,218,.1);transition:.2s}.file-input-wrapper:hover{box-shadow:0 0 12px rgba(100,255,218,.3);background:#121212}.file-input-wrapper input[type=file]{position:absolute;left:0;top:0;opacity:0;cursor:pointer;width:100%;height:100%}.file-input-label{display:block;padding:.5rem 1rem;color:#64ffda;font-weight:600;font-size:.9rem;text-align:center;cursor:pointer;transition:color .2s}.file-input-wrapper:hover .file-input-label{color:#00e6b0}
  </style>
</head>
<body>
  <h1>Replay Trimmer for TETR.IO</h1>
    <div class="controls">
    <div class="file-input-wrapper">
        <span class="file-input-label">Choose Replay File</span>
        <input id="fileInput" type="file" accept=".ttrm,.json" />
    </div>
    </div>


  <div id="roundsContainer"></div>

  <div class="footer-controls">
    <button id="downloadBtn">Download Edited File</button>
  </div>

  <script>
    let replayData = null;
    let usernames = [];      
    let leftUsername = null; 
    let rightUsername = null;

    const fileInput = document.getElementById('fileInput');
    const roundsContainer = document.getElementById('roundsContainer');
    const downloadBtn = document.getElementById('downloadBtn');

    fileInput.addEventListener('change', async (e) => {
      const f = e.target.files[0];
      if (!f) return;
      try {
        const text = await f.text();
        replayData = JSON.parse(text);
      } catch (err) {
        alert('Failed to parse file as JSON.');
        return;
      }

      usernames = [];
      const rounds = replayData?.replay?.rounds || [];
      rounds.forEach((r) => {
        if (!Array.isArray(r)) return;
        r.slice(0,2).forEach(p => {
          if (p && p.username && !usernames.includes(p.username)) usernames.push(p.username);
        });
      });
      leftUsername = usernames[0];
      rightUsername = usernames[1] || usernames[0];
      renderRounds();
    });


    function renderRounds() {
      roundsContainer.innerHTML = '';
      if (!replayData) return;
      const rounds = replayData?.replay?.rounds || [];
      if (!rounds.length) return;
      const header = document.createElement('div');
      header.className = 'header';
      header.innerHTML = `<div>${leftUsername ?? '(choose)'}</div><div>${rightUsername ?? '(choose)'}</div>`;
      roundsContainer.appendChild(header);

      rounds.forEach((round, idx) => {
        if (!Array.isArray(round)) return;
        const players = Array.from(round).slice(0,2); // may be in varying order
        const pLeft = players.find(p => p && p.username === leftUsername) || null;
        const pRight = players.find(p => p && p.username === rightUsername) || null;
        const fallbackLeft = round[0] || null;
        const fallbackRight = round[1] || round[0] || null;

        const leftObj = pLeft || fallbackLeft;
        const rightObj = pRight || fallbackRight;

        const leftAlive = !!(leftObj && leftObj.alive);
        const rightAlive = !!(rightObj && rightObj.alive);

        const roundBox = document.createElement('div');
        roundBox.className = 'round-box';

        const leftPanel = document.createElement('div');
        leftPanel.className = 'player ' + (leftObj ? (leftAlive ? 'alive' : 'dead') : 'neutral');
        leftPanel.innerHTML = buildPlayerHTML(leftObj);

        const middle = document.createElement('div');
        middle.className = 'center';
        const duration = computeDuration(leftObj, rightObj);
        middle.innerHTML = `<div class="round-title">Round #${idx+1}</div><div>${duration}s</div><button class="delete-btn" onclick="deleteRound(${idx})">Delete</button>`;

        const rightPanel = document.createElement('div');
        rightPanel.className = 'player ' + (rightObj ? (rightAlive ? 'alive' : 'dead') : 'neutral');
        rightPanel.innerHTML = buildPlayerHTML(rightObj);

        roundBox.appendChild(leftPanel);
        roundBox.appendChild(middle);
        roundBox.appendChild(rightPanel);
        roundsContainer.appendChild(roundBox);
      });

      downloadBtn.style.display = (rounds.length > 0) ? 'inline-block' : 'none';
    }

    function buildPlayerHTML(p) {
      if (!p) return `<div style="opacity:.5">— missing —</div>`;
      const pps = p.stats?.pps ?? NaN;
      const apm = p.stats?.apm ?? NaN;
      const vs  = p.stats?.vsscore ?? p.stats?.vs ?? NaN;
      return `
        <div class="stats">${isFinite(apm) ? apm.toFixed(2)+' APM' : '—'} ${pps.toFixed(2) + ' PPS'} ${isFinite(vs)  ? vs.toFixed(2)+' VS' : '—'}
        </div>
      `;
    }

    function computeDuration(a,b) {
      const la = a?.lifetime ?? 0;
      const lb = b?.lifetime ?? 0;
      const ms = Math.max(la, lb) || 0;
      return Math.round(ms/1000);
    }

    function deleteRound(index) {
      if (!replayData?.replay?.rounds) return;
      replayData.replay.rounds.splice(index,1);
      renderRounds();
    }

    downloadBtn.addEventListener('click', () => {
    if (!replayData) {
        alert("No replay loaded to download.");
        return;
    }
    const out = JSON.stringify(replayData, null, 2);
    const blob = new Blob([out], { type:'application/json' });
    const url = URL.createObjectURL(blob);

    const a = document.createElement('a');
    a.href = url;
    a.download = 'edited_replay.ttrm';
    document.body.appendChild(a); 
    a.click();
    a.remove(); 
    URL.revokeObjectURL(url);
    });

    window.renderRounds = renderRounds;
    window.deleteRound = deleteRound;
  </script>
</body>
</html>
